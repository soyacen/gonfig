package config

import (
	"fmt"

	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/reflect/protoreflect"
)

type Generator struct {
	Plugin *protogen.Plugin
	File   *protogen.File
}

func NewGenerator(plugin *protogen.Plugin, file *protogen.File) *Generator {
	return &Generator{Plugin: plugin, File: file}
}

func (f *Generator) Generate() error {
	filename := f.File.GeneratedFilenamePrefix + "_gonfig.pb.go"
	g := f.Plugin.NewGeneratedFile(filename, f.File.GoImportPath)
	g.P("// Code generated by protoc-gen-gonfig. DO NOT EDIT.")
	g.P()
	g.P("package ", f.File.GoPackageName)
	g.P()

	messages := f.EnabledMessage()

	g.P("var (")
	for _, message := range messages {
		g.P(f.GlobalConfig(message), " ", Value)
	}
	g.P(")")
	g.P()

	g.P("func init() {")
	for _, message := range messages {
		g.P(f.GlobalConfig(message), ".Store(&", message.GoIdent, "{})")
	}
	g.P("}")
	g.P()

	for _, message := range messages {
		g.P("func ", f.LoadConfig(message), "(ctx ", Context, ", resource ", Resource, ") error {")
		g.P("conf, err := ", Load, "[*", message.GoIdent, "](ctx, resource)")
		g.P("if err != nil {")
		g.P("return err")
		g.P("}")
		g.P(f.GlobalConfig(message), ".Store(conf)")
		g.P("return nil")
		g.P("}")
		g.P()
		g.P("func ", f.WatchConfig(message), "(ctx ", Context, ", resource ", Resource, ", errFunc ", ErrFunc, ") (", StopFunc, ", error) {")
		g.P("stopFunc, err :=", Watch, "[*", message.GoIdent, "](ctx, resource, func(conf *", message.GoIdent, ") { ", f.GlobalConfig(message), ".Store(conf) }, errFunc)")
		g.P("if err != nil {")
		g.P("return nil, err")
		g.P("}")
		g.P("return stopFunc, nil")
		g.P("}")
		g.P()
		g.P("func ", f.GetConfig(message), "() *", message.GoIdent, " {")
		g.P("return ", Clone, "(", f.GlobalConfig(message), ".Load().(*", message.GoIdent, ")).(*", message.GoIdent, ")")
		g.P("}")
		g.P()
		for _, field := range message.Fields {
			goType, _ := fieldGoType(g, field)
			switch {
			case field.Oneof != nil && !field.Oneof.Desc.IsSynthetic():
				return fmt.Errorf("gonfig: oneof field %s is not supported", field.GoName)
			default:
				g.P("func Get", field.GoName, "() ", goType, " {")
				g.P("return ", Clone, "(", f.GlobalConfig(message), ".Load().(*", message.GoIdent, ").Get",field.GoName,"()).(", goType, ")")
				g.P("}")
			}
			g.P()
		}
	}
	return nil
}

func (f *Generator) GetField(field *protogen.Field) string {
	return "Get" + field.GoName
}

func (f *Generator) Config(message *protogen.Message) string {
	return message.GoIdent.GoName
}

func (f *Generator) GlobalConfig(message *protogen.Message) string {
	return "_" + f.Config(message)
}

func (f *Generator) GetConfig(message *protogen.Message) string {
	return "Get" + f.Config(message)
}

func (f *Generator) SetConfig(message *protogen.Message) string {
	return "Set" + f.Config(message)
}

func (f *Generator) LoadConfig(message *protogen.Message) string {
	return "Load" + f.Config(message)
}

func (f *Generator) WatchConfig(message *protogen.Message) string {
	return "Watch" + f.Config(message)
}

func (f *Generator) LoadAndWatchConfig(message *protogen.Message) string {
	return "LoadAndWatch" + f.Config(message)
}

// message 名为 Config\Conf\Configuration
var messageName = []string{"Config", "Conf", "Configuration"}

func (f *Generator) EnabledMessage() []*protogen.Message {
	var messages []*protogen.Message
	for _, message := range f.File.Messages {
		for _, name := range messageName {
			if message.GoIdent.GoName == name {
				messages = append(messages, message)
			}
		}
	}
	return messages
}

var (
	syncPackage = protogen.GoImportPath("sync")
	RWMutex     = syncPackage.Ident("RWMutex")
)

var (
	atomicPackage = protogen.GoImportPath("sync/atomic")
	Value         = atomicPackage.Ident("Value")
)

var (
	protoPackage = protogen.GoImportPath("google.golang.org/protobuf/proto")
	Clone        = protoPackage.Ident("Clone")
)

var (
	contextPackage = protogen.GoImportPath("context")
	Context        = contextPackage.Ident("Context")
)

var (
	configxPackage = protogen.GoImportPath("github.com/soyacen/gonfig")
	Load           = configxPackage.Ident("Load")
	Watch          = configxPackage.Ident("Watch")
)

var (
	resourcePackage = protogen.GoImportPath("github.com/soyacen/gonfig/resource")
	Resource        = resourcePackage.Ident("Resource")
	ErrFunc         = resourcePackage.Ident("ErrFunc")
	StopFunc        = resourcePackage.Ident("StopFunc")
)

// fieldGoType returns the Go type used for a field.
//
// If it returns pointer=true, the struct field is a pointer to the type.
func fieldGoType(g *protogen.GeneratedFile, field *protogen.Field) (goType string, pointer bool) {
	pointer = field.Desc.HasPresence()
	switch field.Desc.Kind() {
	case protoreflect.BoolKind:
		goType = "bool"
	case protoreflect.EnumKind:
		goType = g.QualifiedGoIdent(field.Enum.GoIdent)
	case protoreflect.Int32Kind, protoreflect.Sint32Kind, protoreflect.Sfixed32Kind:
		goType = "int32"
	case protoreflect.Uint32Kind, protoreflect.Fixed32Kind:
		goType = "uint32"
	case protoreflect.Int64Kind, protoreflect.Sint64Kind, protoreflect.Sfixed64Kind:
		goType = "int64"
	case protoreflect.Uint64Kind, protoreflect.Fixed64Kind:
		goType = "uint64"
	case protoreflect.FloatKind:
		goType = "float32"
	case protoreflect.DoubleKind:
		goType = "float64"
	case protoreflect.StringKind:
		goType = "string"
	case protoreflect.BytesKind:
		goType = "[]byte"
		pointer = false // rely on nullability of slices for presence
	case protoreflect.MessageKind, protoreflect.GroupKind:
		goType = "*" + g.QualifiedGoIdent(field.Message.GoIdent)
		pointer = false // pointer captured as part of the type
	}
	switch {
	case field.Desc.IsList():
		return "[]" + goType, false
	case field.Desc.IsMap():
		keyType, _ := fieldGoType(g, field.Message.Fields[0])
		valType, _ := fieldGoType(g, field.Message.Fields[1])
		return fmt.Sprintf("map[%v]%v", keyType, valType), false
	}
	return goType, pointer
}
